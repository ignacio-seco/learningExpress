let jsonArr = [
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { causaMorte: '', morreu: false, dtMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f4f2fb5a338c71ff99a4',
    dadosCruzamentos: [],
    dtNascimento: '2022-05-07',
    estadaCurral: [],
    historico: [],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste4',
    pasto: '',
    pesagem: [],
    producaoLeite: [],
    sexo: 'MACHO',
    createdAt: '2022-12-02T12:52:02.291Z',
    updatedAt: '2022-12-02T12:52:02.291Z',
    __v: 0,
  },
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { causaMorte: '', morreu: false, dtMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f4fafb5a338c71ff99a6',
    dadosCruzamentos: [],
    dtNascimento: '2022-05-07',
    estadaCurral: [],
    historico: [],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste1',
    pasto: '',
    pesagem: [],
    producaoLeite: [],
    sexo: 'MACHO',
    createdAt: '2022-12-02T12:52:10.649Z',
    updatedAt: '2022-12-02T12:52:10.649Z',
    __v: 0,
  },
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { causaMorte: '', morreu: false, dtMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f501fb5a338c71ff99a8',
    dadosCruzamentos: [],
    dtNascimento: '2022-05-07',
    estadaCurral: [],
    historico: [],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste2',
    pasto: '',
    pesagem: [],
    producaoLeite: [],
    sexo: 'MACHO',
    createdAt: '2022-12-02T12:52:17.949Z',
    updatedAt: '2022-12-02T12:52:17.949Z',
    __v: 0,
  },
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { causaMorte: '', morreu: false, dtMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f507fb5a338c71ff99aa',
    dadosCruzamentos: [],
    dtNascimento: '2022-05-07',
    estadaCurral: [],
    historico: [],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste3',
    pasto: '',
    pesagem: [],
    producaoLeite: [],
    sexo: 'MACHO',
    createdAt: '2022-12-02T12:52:23.331Z',
    updatedAt: '2022-12-02T12:52:23.331Z',
    __v: 0,
  },
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { causaMorte: '', morreu: false, dtMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f513fb5a338c71ff99ac',
    dadosCruzamentos: [],
    dtNascimento: '2022-05-07',
    estadaCurral: [],
    historico: [],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste5',
    pasto: '',
    pesagem: [],
    producaoLeite: [],
    sexo: 'FEMEA',
    createdAt: '2022-12-02T12:52:35.297Z',
    updatedAt: '2022-12-02T12:52:35.297Z',
    __v: 0,
  },
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { causaMorte: '', morreu: false, dtMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f51afb5a338c71ff99ae',
    dadosCruzamentos: [],
    dtNascimento: '2022-05-07',
    estadaCurral: [],
    historico: [],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste6',
    pasto: '',
    pesagem: [],
    producaoLeite: [],
    sexo: 'FEMEA',
    createdAt: '2022-12-02T12:52:42.685Z',
    updatedAt: '2022-12-02T12:52:42.685Z',
    __v: 0,
  },
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { causaMorte: '', morreu: false, dtMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f521fb5a338c71ff99b0',
    dadosCruzamentos: [],
    dtNascimento: '2022-05-07',
    estadaCurral: [],
    historico: [],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste7',
    pasto: '',
    pesagem: [],
    producaoLeite: [],
    sexo: 'FEMEA',
    createdAt: '2022-12-02T12:52:49.589Z',
    updatedAt: '2022-12-02T12:52:49.589Z',
    __v: 0,
  },
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { causaMorte: '', morreu: false, dtMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f528fb5a338c71ff99b2',
    dadosCruzamentos: [],
    dtNascimento: '2022-05-07',
    estadaCurral: [],
    historico: [],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste8',
    pasto: '',
    pesagem: [],
    producaoLeite: [],
    sexo: 'FEMEA',
    createdAt: '2022-12-02T12:52:56.227Z',
    updatedAt: '2022-12-02T12:52:56.227Z',
    __v: 0,
  },
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { causaMorte: '', morreu: false, dtMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f52dfb5a338c71ff99b4',
    dadosCruzamentos: [],
    dtNascimento: '2022-05-07',
    estadaCurral: [],
    historico: [],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste9',
    pasto: '',
    pesagem: [],
    producaoLeite: [],
    sexo: 'FEMEA',
    createdAt: '2022-12-02T12:53:01.939Z',
    updatedAt: '2022-12-02T12:53:01.939Z',
    __v: 0,
  },
  {
    dadosCompra: { comprado: false, dtCompra: '' },
    dadosMorte: { morreu: false, dtMorte: '', causaMorte: '' },
    dadosVenda: { vendida: false, dtVenda: '' },
    uuid: '0e0a459d-46e3-4582-9b5b-2ec1c369d1d3',
    _id: '6389f66b4a64f733975ef23e',
    dadosCruzamentos: [
      {
        _id: '638a8699162b47147364efa5',
        animal: '6389f66b4a64f733975ef23e',
        semen: 'não informado',
        dtCruzamento: '2022-05-02',
        confirmaçãoPrenhez: false,
        dtProvavelNascimento: '',
        createdAt: '2022-12-02T23:13:29.802Z',
        updatedAt: '2022-12-02T23:13:29.802Z',
        __v: 0,
      },
    ],
    dtNascimento: '2022-05-07',
    estadaCurral: [
      {
        _id: '638a8709162b47147364efb2',
        animal: '6389f66b4a64f733975ef23e',
        dtEntradaCurral: '2022-05-02',
        dtSaidaCurral: '2022-05-02',
        createdAt: '2022-12-02T23:15:21.514Z',
        updatedAt: '2022-12-02T23:15:21.514Z',
        __v: 0,
      },
    ],
    historico: [
      {
        _id: '638a86bc162b47147364efa8',
        animal: '6389f66b4a64f733975ef23e',
        dtHistorico: '2022-05-02',
        descricao: 'lalalalalalala',
        createdAt: '2022-12-02T23:14:04.543Z',
        updatedAt: '2022-12-02T23:14:04.543Z',
        __v: 0,
      },
    ],
    imagem_url: 'https://pngimg.com/uploads/cow/cow_PNG50576.png',
    noCurral: false,
    nome: 'teste10',
    pasto: '',
    pesagem: [
      {
        _id: '638a86c9162b47147364efab',
        animal: '6389f66b4a64f733975ef23e',
        peso: 50,
        dtPesagem: '2022-05-02',
        createdAt: '2022-12-02T23:14:17.145Z',
        updatedAt: '2022-12-02T23:14:17.145Z',
        __v: 0,
      },
    ],
    producaoLeite: [
      {
        _id: '638a86ee162b47147364efaf',
        animal: '6389f66b4a64f733975ef23e',
        qtdLitros: 12,
        dtVerificacao: '2022-05-02',
        createdAt: '2022-12-02T23:14:54.796Z',
        updatedAt: '2022-12-02T23:14:54.796Z',
        __v: 0,
      },
      {
        _id: '638dfac9932da1d708a0c6c5',
        animal: '6389f66b4a64f733975ef23e',
        qtdLitros: 13,
        dtVerificacao: '2022-05-02',
        createdAt: '2022-12-05T14:06:01.898Z',
        updatedAt: '2022-12-05T14:06:01.898Z',
        __v: 0,
      },
      {
        _id: '638dfad0932da1d708a0c6c8',
        animal: '6389f66b4a64f733975ef23e',
        qtdLitros: 14,
        dtVerificacao: '2022-05-02',
        createdAt: '2022-12-05T14:06:08.505Z',
        updatedAt: '2022-12-05T14:06:08.505Z',
        __v: 0,
      },
      {
        _id: '638dfad7932da1d708a0c6cb',
        animal: '6389f66b4a64f733975ef23e',
        qtdLitros: 15,
        dtVerificacao: '2022-05-02',
        createdAt: '2022-12-05T14:06:15.739Z',
        updatedAt: '2022-12-05T14:06:15.739Z',
        __v: 0,
      },
    ],
    sexo: 'FEMEA',
    createdAt: '2022-12-02T12:58:19.256Z',
    updatedAt: '2022-12-05T14:06:15.741Z',
    __v: 0,
  },
];
function deepSort(conjunto, key) {
  function isAnObject(testedObject) {
    if (
      typeof testedObject === 'object' &&
      !Array.isArray(testedObject) &&
      testedObject !== null
    ) {
      return true;
    } else {
      return false;
    }
  }

  let result = {};
  let tTest = conjunto;
  let arr = [0];
  let i = 0;
  let t;
  let lTest;
  let tType;
  let foundKey;
  let fkTest;
  if (isAnObject(tTest)) {
    lTest = Object.keys(tTest);
  } else {
    lTest = tTest;
  } //observe que isso faz com que lTest seja sempre uma array...

  for (; arr.length > 0; ) {
    //console.log(arr)
    for (; arr[i] < lTest.length; ) {
      if (isAnObject(tTest)) {
        tType = tTest[lTest[arr[i]]];
      } else {
        tType = tTest[arr[i]];
      }
      console.log(
        `This array represent the coordinates that the for loop is looking at [ ${arr} ]`
      ); //O último valor representa a posição que está sendo analisada, enquanto os valores anteriores o caminho que está sendo percorrido até esta posição.
      if (isAnObject(tType)) {
        //aqui começa a formula quando o valor analizado em tTest[arr[i]] é um objeto e poderia ter a key procurada, passos, necessários 1- se tiver a key, fazer o cadastro e procurar no próximo nivel de arr[i], se não tiver a chave, fazer com que i suba de nível e procurar por objetos dentro de objetos ou arrays.
        if (key in tType) {
          foundKey = tType[key];
          //situação em que a chave foi encontrada no objeto
          if (isAnObject(foundKey)) {
            //situação em que a chave é uma array de valores
            fkTest = Object.keys(foundKey);
            if (fkTest.length > 0) {
              for (t = 0; t < fkTest.length; t++) {
                if (!(foundKey[fkTest[t]] in result)) {
                  //aqui testamos se já existe uma key com o nome do valor da chave encontrada. Se tiver o objeto é cadastrado nesse array, se não tiver é criada a chave como o array e o objeto é colocado nela. No primeiro if a chave não existe e precisa ser criada
                  result[foundKey[fkTest[t]]] = [];
                  result[foundKey[fkTest[t]]].push(tType);
                } // situação em que a chave já existia no conjunto result
                else {
                  result[foundKey[fkTest[t]]].push(tType);
                }
              }
              {
                if (Object.keys(tType).length > 0) {
                  // é necessário garantir que não estamos olhando um objeto vazio porque se atualizarmos a profundidade da arvore com objeto vazio a função retornará um erro ao não conseguir ler a propriedade do objeto que não existe.
                  i = i + 1;
                  arr[i] = 0;
                  tTest = tType;
                  lTest = Object.keys(tTest);
                } else {
                  arr[i] = arr[i] + 1;
                }
              }
            } else {
              //situação em que a chave encontrada é uma array vazia
              if (!(`empty` in result)) {
                //aqui testamos se já existe uma key com o nome do valor da chave encontrada. Se tiver o objeto é cadastrado nesse array, se não tiver é criada a chave como o array e o objeto é colocado nela. No primeiro if a chave não existe e precisa ser criada
                result[`empty`] = [];
                result[`empty`].push(tType);
                if (Object.keys(tType).length > 0) {
                  // é necessário garantir que não estamos olhando um objeto vazio porque se atualizarmos a profundidade da arvore com objeto vazio a função retornará um erro ao não conseguir ler a propriedade do objeto que não existe.
                  i = i + 1;
                  arr[i] = 0;
                  tTest = tType;
                  lTest = Object.keys(tTest);
                } else {
                  arr[i] = arr[i] + 1;
                }
              } // situação em que a chave já existia no conjunto result
              else {
                result[`empty`].push(tType);
                if (Object.keys(tType).length > 0) {
                  // é necessário garantir que não estamos olhando um objeto vazio porque se atualizarmos a profundidade da arvore com objeto vazio a função retornará um erro ao não conseguir ler a propriedade do objeto que não existe.
                  i = i + 1;
                  arr[i] = 0;
                  tTest = tType;
                  lTest = Object.keys(tTest);
                } else {
                  arr[i] = arr[i] + 1;
                }
              }
            }
          } else if (Array.isArray(foundKey)) {
            //situação em que a chave é uma array de valores
            if (foundKey.length > 0) {
              for (t = 0; t < foundKey.length; t++) {
                if (!(foundKey[t] in result)) {
                  //aqui testamos se já existe uma key com o nome do valor da chave encontrada. Se tiver o objeto é cadastrado nesse array, se não tiver é criada a chave como o array e o objeto é colocado nela. No primeiro if a chave não existe e precisa ser criada
                  result[foundKey[t]] = [];
                  result[foundKey[t]].push(tType);
                } // situação em que a chave já existia no conjunto result
                else {
                  result[foundKey[t]].push(tType);
                }
              }
              {
                if (Object.keys(tType).length > 0) {
                  // é necessário garantir que não estamos olhando um objeto vazio porque se atualizarmos a profundidade da arvore com objeto vazio a função retornará um erro ao não conseguir ler a propriedade do objeto que não existe.
                  i = i + 1;
                  arr[i] = 0;
                  tTest = tType;
                  lTest = Object.keys(tTest);
                } else {
                  arr[i] = arr[i] + 1;
                }
              }
            } else {
              //situação em que a chave encontrada é uma array vazia
              if (!(`empty` in result)) {
                //aqui testamos se já existe uma key com o nome do valor da chave encontrada. Se tiver o objeto é cadastrado nesse array, se não tiver é criada a chave como o array e o objeto é colocado nela. No primeiro if a chave não existe e precisa ser criada
                result[`empty`] = [];
                result[`empty`].push(tType);
                if (Object.keys(tType).length > 0) {
                  // é necessário garantir que não estamos olhando um objeto vazio porque se atualizarmos a profundidade da arvore com objeto vazio a função retornará um erro ao não conseguir ler a propriedade do objeto que não existe.
                  i = i + 1;
                  arr[i] = 0;
                  tTest = tType;
                  lTest = Object.keys(tTest);
                } else {
                  arr[i] = arr[i] + 1;
                }
              } // situação em que a chave já existia no conjunto result
              else {
                result[`empty`].push(tType);
                if (Object.keys(tType).length > 0) {
                  // é necessário garantir que não estamos olhando um objeto vazio porque se atualizarmos a profundidade da arvore com objeto vazio a função retornará um erro ao não conseguir ler a propriedade do objeto que não existe.
                  i = i + 1;
                  arr[i] = 0;
                  tTest = tType;
                  lTest = Object.keys(tTest);
                } else {
                  arr[i] = arr[i] + 1;
                }
              }
            }
          } else {
            //situação em que a chave encontrada é um valor
            if (!(foundKey in result)) {
              //aqui testamos se já existe uma key com o nome do valor da chave encontrada. Se tiver o objeto é cadastrado nesse array, se não tiver é criada a chave como o array e o objeto é colocado nela. No primeiro if a chave não existe e precisa ser criada
              result[foundKey] = [];
              result[foundKey].push(tType);
              if (Object.keys(tType).length > 0) {
                // é necessário garantir que não estamos olhando um objeto vazio porque se atualizarmos a profundidade da arvore com objeto vazio a função retornará um erro ao não conseguir ler a propriedade do objeto que não existe.
                i = i + 1;
                arr[i] = 0;
                tTest = tType;
                lTest = Object.keys(tTest);
              } else {
                arr[i] = arr[i] + 1;
              }
            } // situação em que a chave já existia no conjunto result
            else {
              result[foundKey].push(tType);
              if (Object.keys(tType).length > 0) {
                // é necessário garantir que não estamos olhando um objeto vazio porque se atualizarmos a profundidade da arvore com objeto vazio a função retornará um erro ao não conseguir ler a propriedade do objeto que não existe.
                i = i + 1;
                arr[i] = 0;
                tTest = tType;
                lTest = Object.keys(tTest);
              } else {
                arr[i] = arr[i] + 1;
              }
            }
          }
        } //aqui encerra a situação em que a chave foi encontrada.
        else {
          //situação em que a chave não foi encontrada no objeto
          if (Object.keys(tType).length > 0) {
            // é necessário garantir que não estamos olhando um objeto vazio porque se atualizarmos a profundidade da arvore com objeto vazio a função retornará um erro ao não conseguir ler a propriedade do objeto que não existe.
            i = i + 1;
            arr[i] = 0;
            tTest = tType;
            lTest = Object.keys(tTest);
          } else {
            arr[i] = arr[i] + 1;
          }
        }
      } else if (Array.isArray(tType)) {
        //aqui começa as ações se o item que está sendo analisado é uma array, e não pode ter a chave: passos, apenas subir um nível em arr[i] e atualizar o ltest para que represente o novo tamanho do novo nível do arr[i]
        if (tType.length > 0) {
          i = i + 1;
          arr[i] = 0;
          tTest = tType;
          lTest = tTest;
        } else {
          arr[i] = arr[i] + 1;
        }
      } else {
        arr[i] = arr[i] + 1; //nesse caso o item é um valor e o loop deve apenas continuar sem atualizar o lTest
      }
    }
    {
      //aqui é a ação a ser tomada quando o o valor de arr[i] ultrapassar o valor de length da array ltest. É melhor cadastrar a regra para conter o loop do primeiro for aqui uma vez que, aqui, é possível utilizar regras if enquanto no loop for não é...
      if (arr.length > 1) {
        console.log(`This is the array before the pop() comand [${arr}]`);
        i = i - 1; //isso retrocede a profundidade paara o nível anterior
        arr[i] = arr[i] + 1; //isso faz com que o loop não olhe o mesmo item novamente e siga em frente com a checagem
        arr.pop(); ///isso diminui o valor de arr.length e é necessário para o primeiro loop não ser eterno.
        console.log(`This is the new array after the pop() comand [${arr}]`);
        //nessa etapa é necessário reconstruir o tTest e o lTest para que eles estejam em conformidade com os valores que serão analisados, para isso usamos as coordenadas que já existem na array arr. O problema é que é necessário checar, para cada valor desse, se o que está ali é um objeto ou um array e no caso de objeto cadastrar a key no tTest e não o valor como fazemos com uma array. Ao final, atualizar o valor ltest para garantir que seja tratado como uma array ainda que o tTest final seja um objeto.
        tTest = conjunto;
        for (let y = 0; y < arr.length - 1; y++) {
          if (isAnObject(tTest)) {
            tTest = tTest[Object.keys(tTest)[arr[y]]];
          } else {
            tTest = tTest[arr[y]];
          }
        }
        {
          if (isAnObject(tTest)) {
            lTest = Object.keys(tTest);
          } else {
            lTest = tTest;
          }
        }
        //aqui comecei a inserir a checagem de undefined
      } //aqui se encerra o if
      else {
        arr.pop();
        ///nessa situação a formula se caminha para a derradeira conclusão.
      }
    }
  }
  {
    //resultado quando toda formula encerra
    return result;
  }
}

let updateArray = deepSort(jsonArr, '_id');
let itensToUpdate = Object.keys(updateArray);
console.log(updateArray)

function setToMongoFormat(updateObject, idkey) {
    function isAnObject(testedObject) {
        if (
          typeof testedObject === 'object' &&
          !Array.isArray(testedObject) &&
          testedObject !== null
        ) {
          return true;
        } else {
          return false;
        }
      }
  let itensToUpdate = { ...updateObject };
  let idArray = Object.keys(itensToUpdate);
  idArray.forEach((id) => {
    let document = itensToUpdate[id][0];
    let keys = Object.keys(document);
    keys.forEach((key) => {
      if (Array.isArray(document[key])) {
        let newArray = [];
        let arrayOfitens = document[key];
        arrayOfitens.forEach((element) => {
          if (isAnObject(element) && idkey in element) {
            newArray.push(element[idkey]);
          } else {
            newArray.push(element);
          }
        });
        document[key] = newArray;
      }
    });
  });
  return itensToUpdate;
}
let dataToPass = setToMongoFormat(updateArray, '_id');
console.log(dataToPass)
console.log(dataToPass['6389f66b4a64f733975ef23e'][0]['producaoLeite']);
